<!DOCTYPE html>
<!-- saved from url=(0044)http://zetcode.com/lang/rubytutorial/hashes/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Ruby hashes</title>
<link rel="stylesheet" href="./Ruby hashes_files/format2.css" type="text/css">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="keywords" content="Ruby, learn Ruby, hash, tutorial, programming language">
<meta name="description" content="In this part of the Ruby tutorial, we cover hashes.">
<meta name="author" content="Jan Bodnar">

<style type="text/css"></style><link rel="stylesheet" type="text/css" href="./Ruby hashes_files/dark-floating.css"></head>

<body><div class="cc_banner-wrapper "><div class="cc_banner cc_container cc_container--open"><a href="http://zetcode.com/lang/rubytutorial/hashes/#null" data-cc-event="click:dismiss" target="_blank" class="cc_btn cc_btn_accept_all">Got it!</a><p class="cc_message">This website uses cookies to ensure you get the best experience on our website </p><a class="cc_logo" target="_blank" href="http://silktide.com/cookieconsent">Cookie Consent plugin for the EU cookie law</a></div></div>

<div class="container">

<div id="wide_ad" class="ltow">
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 160x600, August 2011 -->
<ins class="adsbygoogle" style="display:inline-block;width:160px;height:600px" data-ad-client="ca-pub-9706709751191532" data-ad-slot="2484182563"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>


<div class="content">


<header>

<nav>
<a href="http://zetcode.com/" title="Home">Home</a>
<a href="http://zetcode.com/lang/rubytutorial/">Contents</a>

<div class="nav_r">
<a href="http://zetcode.com/lang/rubytutorial/arrays/">Previous</a>
<a href="http://zetcode.com/lang/rubytutorial/oop/">Next</a>
</div>
</nav>

</header>



<h1>Ruby hashes</h1>

<p>
This part of the Ruby tutorial will mention Ruby hashes. A hash is a collection
of key-value pairs. It is similar to an array. Unlike arrays, hashes can have
arbitrary objects as indexes. Arrays have can only have integers. Hashes
are sometimes called associated arrays. 
</p>

<div class="big_hor">
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- big_horizontal -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-9706709751191532" data-ad-slot="2904953388"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>


<p>
Hashes are powerful collections. They have many methods that programmers
can use to do their work.
</p>


<h2>Hash creation</h2>

<p>
A hash can be created in two basic ways: with the <code>new</code> keyword 
or with the hash literal.
</p>

<pre class="code">#!/usr/bin/ruby

names = Hash.new
names[1] = "Jane"
names[2] = "Thomas"

puts names
</pre>

<p>
The first script creates a hash and adds two key-value pairs into the
hash object. 
</p>

<pre class="explanation">names = Hash.new
</pre>

<p>
A hash object is created. 
</p>

<pre class="explanation">names[1] = "Jane"
names[2] = "Thomas"
</pre>

<p>
We add two pairs of values to the hash. The numbers 1, 2 are the keys
to the hash. The keys are placed inside the square brackets. 
The names are the values that belong to the keys. 
</p>

<pre class="explanation">puts names
</pre>

<p>
The <code>puts</code> method prints the string representation of the
hash to the console. It is also the string literal of the hash.
</p>

<pre>$ ./create.rb
{1=&gt;"Jane", 2=&gt;"Thomas"}
</pre>

<p>
From the output we can see the literal representation of the names hash.
A hash is bounded by curly brackets. The keys and the values are paired 
with the <code>=&gt;</code> characters. 
</p>

<p>
A <code>store</code> method can be used to initialize the hash with
some values. It can be use instead of the square brackets. 
</p>

<pre class="code">#!/usr/bin/ruby

names = Hash.new
names.store(1, "Jane")
names.store(2, "Thomas")
names.store(3, "Rebecca")

puts names
</pre>

<p>
We have a similar script. This time we use the <code>store</code>
method. The method associates the given key with the given value 
and stores the pair in the hash. 
</p>

<pre class="explanation">names.store(1, "Jane")
</pre>

<p>
The first parameter of the <code>store</code> method is the key and the 
second parameter is the value. 
</p>

<p>
In the third script, we create a hash with the hash literal notation. 
The values are bound by the curly brackets. And the key-value pairs
are associated with the <code>=&gt;</code> characters. 
</p>

<pre class="code">#!/usr/bin/ruby

domains = { "de" =&gt; "Germany",
            "sk" =&gt; "Slovakia",
            "hu" =&gt; "Hungary",
            "us" =&gt; "United States",
            "no" =&gt; "Norway"                       
          }

puts domains["de"]
puts domains["sk"]
</pre>

<p>
We create a domains hash with 5 pairs. This time both
keys and values are string types.
</p>

<pre class="explanation">domains = { "de" =&gt; "Germany",
            "sk" =&gt; "Slovakia",
            "hu" =&gt; "Hungary",
            "us" =&gt; "United States",
            "no" =&gt; "Norway"                       
          }
</pre>

<p>
This is a hash literal notation. The key-value pairs are put
between the curly brackets. The items are separated by the comma
character. And the keys are associated with values using the 
<code>=&gt;</code> characters combination. 
</p>

<pre class="explanation">puts domains["de"]
</pre>

<p>
Here we print the domain value name associated with the "de" key. 
</p>

<pre>$ ./create3.rb 
Germany
Slovakia
</pre>

<p>
This is the output of the code example. 
</p>


<h2>Basic work</h2>

<p>
In this section, we present some methods for the very 
basic work with Ruby hashes. 
</p>

<pre class="code">#!/usr/bin/ruby

names = Hash.new

names[1] = "Jane"
names[2] = "Thomas"
names[3] = "Robert"
names[4] = "Julia"
names[5] = "Rebecca"

puts "The size of the hash is #{names.size}"

puts names.keys.inspect
puts names.values.inspect
</pre>

<p>
In the above Ruby script, we create a hash with five values.
We introduce three hash methods. 
</p>

<pre class="explanation">puts "The size of the hash is #{names.size}"
</pre>

<p>
The <code>size</code> method returns the size of the hash.
It is a synonym for the <code>length</code> method.
</p>

<pre class="explanation">puts names.keys.inspect
puts names.values.inspect
</pre>

<p>
The <code>keys</code> method returns all keys of the hash. 
In a similar fashion, the <code>values</code> method returns
all the values of the hash. The returned data is in the form of 
an array. To have a more readable output, we also call the 
<code>inspect</code> method on the returned arrays. 
</p>

<pre>$ ./basic.rb
The size of the hash is 5
[1, 2, 3, 4, 5]
["Jane", "Thomas", "Robert", "Julia", "Rebecca"]
</pre>

<p>
We see the output of the example. Note that the output of the last 
two methods are two arrays. 
</p>

<p>
The second example of the section presents three distinct hash methods.
</p>

<pre class="code">#!/usr/bin/ruby

names1 = Hash.new

names1[1] = "Jane"
names1[2] = "Thomas"
names1[3] = "Robert"
names1[4] = "Julia"
names1[5] = "Rebecca"

names2 = names1.dup

puts names1.eql? names2

puts names1.empty?
names1.clear
puts names1.empty?
</pre>

<p>
The Ruby script creates a names hash. It calls three hash
methods on the object. 
</p>

<pre class="explanation">names2 = names1.dup
</pre>

<p>
We create a duplicate of the hash by calling the <code>dup</code>
method. The method is inherited by the hash from the parent object.
</p>

<pre class="explanation">puts names1.eql? names2
</pre>

<p>
The <code>eql?</code> method compares two hash objects. In our case
the hashes are equal and the line prints true.
</p>

<pre class="explanation">puts names1.empty?
</pre>

<p>
The <code>empty?</code> method checks whether the hash is empty or not.
The line print false because the names1 hash has five items. 
</p>

<pre class="explanation">names1.clear
puts names1.empty?
</pre>

<p>
The <code>clear</code> method deletes all items from the hash. The successive
call of the <code>empty?</code> method returns true. 
</p>

<pre>$ ./basic2.rb
true
false
true
</pre>

<p>
This is the example output. 
</p>


<p>
We have methods that can determine whether a key or a value
is present in the hash. 
</p>

<pre class="code">#!/usr/bin/ruby

domains = { :de =&gt; "Germany", :sk =&gt; "Slovakia",
            :no =&gt; "Norway", :us =&gt; "United States"
          }

puts domains.has_key? :de
puts domains.include? :no
puts domains.key? :me
puts domains.member? :sk

puts domains.has_value? "Slovakia"
puts domains.value? "Germany"
</pre>

<p>
We create a domains hash with four pairs. The keys are
symbols. Symbols are often used as keys, because they are more
efficient. 
</p>

<pre class="explanation">puts domains.has_key? :de
puts domains.include? :no
puts domains.key? :me
puts domains.member? :sk
</pre>

<p>
Here we have four methods that determine whether a key is in the hash.
They all do the same; they are synonyms. 
</p>

<pre class="explanation">puts domains.has_value? "Slovakia"
puts domains.value? "Germany"
</pre>

<p>
These two methods check if the two strings are inside the hash. 
</p>

<pre>$ ./has.rb
true
true
false
true
true
true
</pre>

<p>
This is the output of the example. 
</p>

<p>
In the final example of the section, we will read values from the hash.
</p>

<pre class="code">#!/usr/bin/ruby

stones = { 1 =&gt; "garnet", 2 =&gt; "topaz", 
           3 =&gt; "opal", 4 =&gt; "amethyst"
         }

puts stones.fetch 1
puts stones[2]
puts stones.values_at 1, 2, 3
</pre>

<p>
The Ruby script presents three hash methods for reading values of
a hash. 
</p>

<pre class="explanation">puts stones.fetch 1
</pre>

<p>
The <code>fetch</code> method reads a value for a given key. 
</p>

<pre class="explanation">puts stones[2]
</pre>

<p>
Square brackets can be used to get a value. In our case, the line
prints "topaz" to the console. 
</p>

<pre class="explanation">puts stones.values_at 1, 2, 3
</pre>

<p>
The <code>values_at</code> method can be used to get multiple values
at one step. The method returns an array of the values for the given
keys. 
</p>

<pre>$ ./read.rb
garnet
topaz
garnet
topaz
opal
</pre>

<p>
This is the output of the example. 
</p>


<h2>Looping through a hash</h2>

<p>
There are several methods that can be used to loop through a
Ruby hash. 
</p>

<pre class="code">#!/usr/bin/ruby

stones = { 1 =&gt; "garnet", 2 =&gt; "topaz", 
           3 =&gt; "opal", 4 =&gt; "amethyst"
         }

stones.each { |k, v| puts "Key: #{k}, Value: #{v}" }
stones.each_key { |key| puts "#{key}" }
stones.each_value { |val| puts "#{val}" }
stones.each_pair { |k, v| puts "Key: #{k}, Value: #{v}" }
</pre>

<p>
In the above example, we present four methods. We use them to 
display all keys, values and both keys and values of a hash. 
</p>


<pre class="explanation">stones.each { |k, v| puts "Key: #{k}, Value: #{v}" }
</pre>

<p>
The <code>each</code> method calls the given block for each
key in the hash, passing key-value pair as parameter. 
</p>

<pre class="explanation">stones.each_key { |key| puts "#{key}" }
</pre>

<p>
We use the <code>each_key</code> method to loop throug all
keys of a hash. They are printed to the console. 
</p>

<pre class="explanation">stones.each_value { |val| puts "#{val}" }
</pre>

<p>
The <code>each_value</code> can be used to loop throug
the values of a hash. 
</p>

<pre class="explanation">stones.each_pair { |k, v| puts "Key: #{k}, Value: #{v}" }
</pre>

<p>
The <code>each_pair</code> method is a synonym for the 
<code>each</code> method. We loop through the keys and values
of the stones hash.
</p>

<pre>$ ./loop.rb
Key: 1, Value: garnet
Key: 2, Value: topaz
Key: 3, Value: opal
Key: 4, Value: amethyst
1
2
3
4
garnet
topaz
opal
amethyst
Key: 1, Value: garnet
Key: 2, Value: topaz
Key: 3, Value: opal
Key: 4, Value: amethyst
</pre>

<p>
The output shows the keys and values, keys, values of
the stones hash. 
</p>


<h2>Deleting pairs</h2>

<p>
In the following examples, we will concern ourselves with methods
that delete pairs from the hashes. This includes methods that delete individual pairs 
as well as methods that can delete multiple key-values at one step.
</p>

<pre class="code">#!/usr/bin/ruby

names = Hash.new

names[1] = "Jane"
names[2] = "Thomas"
names[3] = "Robert"
names[4] = "Julia"
names[5] = "Rebecca"

names.delete 4
names.shift

puts names
</pre>

<p>
In the script we have two methods: <code>delete</code> and <code>shift</code>. 
The <code>delete</code> method removes and returns a value for a specified key. 
The <code>shift</code> method deletes the first pair from the hash. It also returns 
the removed pair as an array. 
</p>

<pre class="explanation">names.delete 4
</pre>

<p>
Here we delete a pair 4 =&gt; "Julia". 
</p>

<pre class="explanation">names.shift
</pre>

<p>
This code line removes the first pair, namely 1 =&gt; "Jane". 
</p>

<pre>$ ./deleteitem.rb
{2=&gt;"Thomas", 3=&gt;"Robert", 5=&gt;"Rebecca"}
</pre>

<p>
In the output we can see the pairs of the hash that are left. 
</p>


<p>
The <code>reject</code> and the <code>delete_if</code> methods can
remove multiple pairs from a hash. The methods delete pairs that
return true for the given condition in the block. There is an important 
distinction between the two methods. The <code>reject</code> method
works on a copy of a hash while the <code>delete_if</code> works on
the original hash. 
</p>

<pre class="code">#!/usr/local/bin/ruby

names1 = Hash.new

names1[1] = "Jane"
names1[2] = "Thomas"
names1[3] = "Robert"
names1[4] = "Julia"
names1[5] = "Rebecca"

puts names1.reject { |k, v| v =~ /R.*/ }
puts names1
puts names1.delete_if { |k, v| k&lt;=3 }
puts names1
</pre>

<p>
The example deletes multiple pairs using the previously mentioned
methods. 
</p>

<pre class="explanation">puts names1.reject { |k, v| v =~ /R.*/ }
</pre>

<p>
The <code>reject</code> method removes all values that fit the
regular expression in the block. The modified hash is returned and
the original hash is not changed. 
</p>

<pre class="explanation">puts names1
</pre>

<p>
The output of this line confirms that the original hash was intact. 
</p>

<pre class="explanation">puts names1.delete_if { |k, v| k&lt;=3 }
</pre>

<p>
In this case, we delete all pairs, for which the key is lower or
equal to 3. The method modifies the original hash. 
</p>

<pre>$ ./massdelete.rb 
{1=&gt;"Jane", 2=&gt;"Thomas", 4=&gt;"Julia"}
{1=&gt;"Jane", 2=&gt;"Thomas", 3=&gt;"Robert", 4=&gt;"Julia", 5=&gt;"Rebecca"}
{4=&gt;"Julia", 5=&gt;"Rebecca"}
{4=&gt;"Julia", 5=&gt;"Rebecca"}
</pre>

<p>
Output of the example. 
</p>


<h2>Adding hashes</h2>

<p>
Ruby's merge and update methods add (key, value) pairs to hashes.
Ruby has methods for hash addition. 
</p>

<pre class="code">#!/usr/bin/ruby

names1 = Hash.new

names1[1] = "Jane"
names1[2] = "Thomas"

names2 = Hash.new

names2[3] = "Robert"
names2[4] = "Julia"

names = names1.merge names2
puts names

names = names1.update names2
puts names
</pre>

<p>
In the Ruby script, we create two hashes. Then we apply 
<code>merge</code> and <code>update</code> methods on them. 
</p>

<pre class="explanation">names = names1.merge names2
puts names
</pre>

<p>
The names1 and names2 hashes are combined.  
The result is assigned to the names hash. We print the newly created hash. 
</p>

<pre>$ ./merge.rb
{1=&gt;"Jane", 2=&gt;"Thomas", 3=&gt;"Robert", 4=&gt;"Julia"}
{1=&gt;"Jane", 2=&gt;"Thomas", 3=&gt;"Robert", 4=&gt;"Julia"}
</pre>

<p>
As we can see, the final hashes contain pairs from the <code>names1</code> and
<code>names2</code> hashes. 
</p>


<h2>The merge vs merge!</h2>

<p>
In the final section, we recap a common Ruby idiom. 
Several Ruby methods have counterparts that end with an exclamation point. 
This mark, which has no syntactic significance, indicates that a method modifies 
the object on which that method is called.
</p>

<pre class="code">#!/usr/bin/ruby

names1 = Hash.new

names1[1] = "Jane"
names1[2] = "Thomas"

names2 = Hash.new

names2[3] = "Robert"
names2[4] = "Julia"

names = names1.merge names2
puts names
puts names1

names = names1.merge! names2
puts names
puts names1
</pre>

<p>
We will demonstrate the difference on the <code>merge</code> 
and <code>merge!</code> methods. 
</p>

<pre class="explanation">names = names1.merge names2
</pre>

<p>
The <code>merge</code> does not modify the <code>names1</code> hash. It works
on its copy.
</p>

<pre class="explanation">names = names1.merge! names2
</pre>

<p>
The <code>merge!</code> method works on the original hash. The <code>names1</code>
hash is changed. 
</p>


<pre>$ ./merge2.rb
{1=&gt;"Jane", 2=&gt;"Thomas", 3=&gt;"Robert", 4=&gt;"Julia"}
{1=&gt;"Jane", 2=&gt;"Thomas"}
{1=&gt;"Jane", 2=&gt;"Thomas", 3=&gt;"Robert", 4=&gt;"Julia"}
{1=&gt;"Jane", 2=&gt;"Thomas", 3=&gt;"Robert", 4=&gt;"Julia"}
</pre>

<p>
This is the output of the <code>merge2.rb</code> program.
</p>

<p>
In this chapter, we worked with Ruby hashes. 
</p>


<div class="big_hor">
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- big_horizontal -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-9706709751191532" data-ad-slot="2904953388"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<footer>

<nav>
<a href="http://zetcode.com/">Home</a>
<a href="http://zetcode.com/lang/rubytutorial/">Contents</a>  
<a href="http://zetcode.com/lang/rubytutorial/hashes/#">Top of Page</a>

<div class="nav_r">
<a href="http://zetcode.com/lang/rubytutorial/arrays/">Previous</a>
<a href="http://zetcode.com/lang/rubytutorial/oop/">Next</a>
</div>
</nav>


<div class="signature">
<a href="http://zetcode.com/">ZetCode</a> last modified October 3, 2014 <span class="copyright">© 2007 - 2016 Jan Bodnar</span>
</div>

</footer>

</div> <!-- content -->

</div> <!-- container -->

<!-- Silktide Cookie -->
<script>
    window.cookieconsent_options = {"message":"This website uses cookies to ensure you get the best experience on our website",
    "dismiss":"Got it!","learnMore":"More info","link":null,"theme":"dark-floating"};
</script>

<script src="./Ruby hashes_files/cookieconsent.min.js"></script>




</body></html>